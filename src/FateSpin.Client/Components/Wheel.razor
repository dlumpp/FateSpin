<div class="wheel-container">
    <div class="wheel-wrapper">
        <div class="wheel" 
             style="@GetWheelStyle(); transform: rotate(@(currentRotation)deg); @(isSpinning ? "transition: transform 3s cubic-bezier(0.23, 1, 0.32, 1);" : "")">
            <svg class="wheel-text" viewBox="0 0 200 200">
                @for (int i = 0; i < wheelItems.Count; i++)
                {
                    @RenderTextElement(i)
                }
            </svg>
        </div>
        <div class="pointer"></div>
        <button class="spin-button" @onclick="SpinWheel" disabled="@isSpinning">
            @(isSpinning ? luckyClover : "Spin!")
        </button>
    </div>
    
    <div class="input-section">
        <h3>Customize Your Wheel</h3>
        <textarea @bind="userInput" @oninput="OnInputChanged" 
                  placeholder="Enter one item per line&#10;Eat&#10;Sleep&#10;Code" 
                  class="wheel-input"></textarea>
    </div>
</div>

@code {
    // Default wheel items
    private List<string> wheelItems = new List<string> { "Eat", "Sleep", "Code" };
    private string userInput = "Eat\nSleep\nCode";
    private double degreesPerWedge => wheelItems.Count > 0 ? 360.0 / wheelItems.Count : 360.0;
    
    // Theme-appropriate colors that complement the dark background
    private string[] wedgeColors = {
        "#dc3545", // Original red
        "#fd7e14", // Orange  
        "#ffc107", // Yellow
        "#198754", // Green
        "#0dcaf0", // Cyan
        "#6f42c1"  // Purple
    };

    private bool isSpinning = false;
    private double currentRotation = 0;
    private Random random = new Random();

    private void OnInputChanged(ChangeEventArgs e)
    {
        if (e.Value != null)
        {
            userInput = e.Value.ToString()!;
            UpdateWheelItems();
        }
    }

    private MarkupString RenderTextElement(int index)
    {
        // Calculate the angle for this wedge (0 degrees is at 3 o'clock position, where the pointer is)
        // CSS conic-gradient now starts from 90deg to align with pointer position
        var angle = (index * degreesPerWedge) + (degreesPerWedge / 2);
        
        var text = wheelItems[index];
        var safeText = text.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;").Replace("\"", "&quot;");
        
        // Dynamic positioning and sizing based on text length and wedge size
        var baseRadius = 40;
        var wedgeWidth = degreesPerWedge * Math.PI / 180 * 80; // Arc length at radius 80
        var textLength = text.Length;
        
        // Adjust radius based on text length - longer text moves inward to fit better
        var radius = textLength > 8 ? Math.Max(baseRadius - (textLength - 8) * 2, 25) : baseRadius;
        
        // Dynamic font size based on text length and available wedge space
        var baseFontSize = 14.0;
        var fontSize = Math.Max(baseFontSize - Math.Max(0, textLength - 6), 8.0);
        fontSize = Math.Min(fontSize, wedgeWidth / textLength * 1.2); // Scale to fit wedge width
        
        var x = 100 + (radius * Math.Cos(angle * Math.PI / 180));
        var y = 100 + (radius * Math.Sin(angle * Math.PI / 180));
        
        // Rotate text so it reads radially outward from center
        var textRotation = angle;
        
        return new MarkupString($@"<text x=""{x:F2}"" y=""{y:F2}"" 
                                        text-anchor=""start"" 
                                        dominant-baseline=""middle""
                                        transform=""rotate({textRotation:F2} {x:F2} {y:F2})""
                                        class=""wheel-label""
                                        style=""font-size: {fontSize:F1}px;"">
                                        {safeText}
                                   </text>");
    }

    private void UpdateWheelItems()
    {
        var items = userInput.Split('\n', StringSplitOptions.RemoveEmptyEntries)
                            .Select(item => item.Trim())
                            .Where(item => !string.IsNullOrEmpty(item))
                            .ToList();
        
        if (items.Count > 0)
        {
            wheelItems = items;
        }
        else
        {
            wheelItems = new List<string> { "Empty" };
        }
        StateHasChanged();
    }

    private string GetWheelStyle()
    {
        var gradientStops = new List<string>();
        double currentAngle = 0;
        
        for (int i = 0; i < wheelItems.Count; i++)
        {
            string color = wedgeColors[i % wedgeColors.Length];
            double nextAngle = currentAngle + degreesPerWedge;
            
            gradientStops.Add($"{color} {currentAngle}deg {nextAngle}deg");
            currentAngle = nextAngle;
        }
        
        // Start gradient from 90deg (3 o'clock) to align with pointer position
        return $"background: conic-gradient(from 90deg, {string.Join(", ", gradientStops)});";
    }

    private string luckyClover = "\U0001F340";

    private async Task SpinWheel()
    {
        if (isSpinning) return;
        
        isSpinning = true;
        
        // Generate random spin amount (multiple full rotations + random final position)
        int fullRotations = random.Next(3, 6); // 3-5 full rotations
        double finalPosition = random.NextDouble() * 360; // Random final position
        double totalRotation = (fullRotations * 360) + finalPosition;
        
        // Calculate target rotation
        double targetRotation = currentRotation + totalRotation;
        
        StateHasChanged();
        
        // Small delay to ensure the transition CSS is applied
        await Task.Delay(50);
        
        // Set the new rotation which will trigger the CSS transition
        currentRotation = targetRotation;
        StateHasChanged();
        
        // Wait for animation to complete (3 seconds)
        await Task.Delay(3000);
        
        // Normalize rotation to keep it within 0-360 range for future spins
        currentRotation = currentRotation % 360;
        isSpinning = false;
        StateHasChanged();
    }
}