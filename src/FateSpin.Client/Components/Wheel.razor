<div class="wheel-container">
    <div class="wheel" 
         style="@GetWheelStyle(); transform: rotate(@(currentRotation)deg); @(isSpinning ? "transition: transform 3s cubic-bezier(0.23, 1, 0.32, 1);" : "")"></div>
    <div class="pointer"></div>
    <button class="spin-button" @onclick="SpinWheel" disabled="@isSpinning">
        @(isSpinning ? "Spinning..." : "Spin")
    </button>
</div>

@code {
    // Hard-coded number of wedges for now - will be configurable later
    private int numberOfWedges = 6;
    private double degreesPerWedge => 360.0 / numberOfWedges;
    
    // Theme-appropriate colors that complement the dark background
    private string[] wedgeColors = {
        "#dc3545", // Original red
        "#fd7e14", // Orange  
        "#ffc107", // Yellow
        "#198754", // Green
        "#0dcaf0", // Cyan
        "#6f42c1"  // Purple
    };

    private bool isSpinning = false;
    private double currentRotation = 0;
    private Random random = new Random();

    private string GetWheelStyle()
    {
        var gradientStops = new List<string>();
        double currentAngle = 0;
        
        for (int i = 0; i < numberOfWedges; i++)
        {
            string color = wedgeColors[i % wedgeColors.Length];
            double nextAngle = currentAngle + degreesPerWedge;
            
            gradientStops.Add($"{color} {currentAngle}deg {nextAngle}deg");
            currentAngle = nextAngle;
        }
        
        return $"background: conic-gradient(from 0deg, {string.Join(", ", gradientStops)});";
    }

    private async Task SpinWheel()
    {
        if (isSpinning) return;
        
        isSpinning = true;
        
        // Generate random spin amount (multiple full rotations + random final position)
        int fullRotations = random.Next(3, 6); // 3-5 full rotations
        double finalPosition = random.NextDouble() * 360; // Random final position
        double totalRotation = (fullRotations * 360) + finalPosition;
        
        // Calculate target rotation
        double targetRotation = currentRotation + totalRotation;
        
        StateHasChanged();
        
        // Small delay to ensure the transition CSS is applied
        await Task.Delay(50);
        
        // Set the new rotation which will trigger the CSS transition
        currentRotation = targetRotation;
        StateHasChanged();
        
        // Wait for animation to complete (3 seconds)
        await Task.Delay(3000);
        
        // Normalize rotation to keep it within 0-360 range for future spins
        currentRotation = currentRotation % 360;
        isSpinning = false;
        StateHasChanged();
    }
}